<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>WebGL</title>
  <style>
    .wrapper{
        display: grid;
        grid-template: 1fr / 1fr;
    }
    #c {
        grid-row: 1 / 2;
        grid-column: 1 / 2;
    }

    #video {
        grid-row: 1 / 2;
        grid-column: 1 / 2;
    }
  </style>
</head>
<body>
    <div class="wrapper">
        <video id="video" src="./assets/video/metro.mp4" preload="auto" muted autoplay playsinline></video>
        <canvas id="c"></canvas>
    </div>
  

  <script>
  {

const createShader = (gl, type, source) => {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (success) {
    return shader;
  }
  console.error(gl.getShaderInfoLog(shader));
  gl.deleteShader(shader);
};

const createProgram = (gl, vertexShader, fragmentShader) => {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  const success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (success) {
    return program;
  }
  console.error(gl.getProgramInfoLog(program));
  gl.deleteProgram(program);
};

const canvas = document.querySelector('#c');
const $video = document.getElementById('video');
const gl = canvas.getContext('webgl');
const vertexShader = createShader(gl, gl.VERTEX_SHADER, `
precision mediump float;

attribute vec2 a_position;
attribute vec2 a_texCoord;

varying vec2 uv;

void main() {     
  gl_Position = vec4(a_position, 1, 1);
  uv = a_texCoord;
}
`);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `
    precision mediump float;

    uniform sampler2D iChannel0;
    uniform float iTime;
    uniform float mirrorPos;

    uniform vec3 iResolution;

    varying vec2 uv;

    #define CRT_STRENGTH 0.8
    #define CA_MAX_PIXEL_DIST 5.0
    #define BORDER_SIZE 0.2
    #define BORDER_STRENGTH 0.8
    #define SATURATION 1.4


    vec4 read(vec2 uv)
    {
        //you might wanna do stuff here when using this in your shader
        return texture2D(iChannel0, uv);
    }
    vec3 saturation(vec3 rgb, float amount)
    {
        const vec3 W = vec3(0.2125, 0.7154, 0.0721);
        vec3 intensity = vec3(dot(rgb, W));
        return mix(intensity, rgb, amount);
    }
    void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {
        vec2[3] ca;
        ca[0] = vec2(-CA_MAX_PIXEL_DIST, -CA_MAX_PIXEL_DIST);
        ca[1] = vec2(0.0);
        ca[2] = vec2(CA_MAX_PIXEL_DIST, CA_MAX_PIXEL_DIST);
        
        vec2 pixel = 1.0 / iResolution.xy;
        vec2 uv = fragCoord * pixel;


        int row = int(fragCoord.y)%2;
        int col = (int(fragCoord.x)+row)%3;
        
        vec2 nuv = 2. * abs(uv-vec2(0.5));
        vec2 caShift = (length(nuv) / sqrt(2.0)) * pixel;
        
        vec3 src = vec3(0.0);
        for(int i = 0; i < 3; i++)
        {
            src[i] = read(uv - ca[i] * caShift)[i] * ((i==col) ? 1.0 : 1.-CRT_STRENGTH);
        }
        float d = (1.-nuv.x) * (1.-nuv.y);
        d = (1.-BORDER_STRENGTH) + BORDER_STRENGTH * smoothstep(0.0, BORDER_SIZE, sqrt(d));
        src *= d;
        src = saturation(src, SATURATION);
        fragColor = vec4(src,1.0);
    }
    void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
    }
`);
const program = createProgram(gl, vertexShader, fragmentShader);
const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
const positionBuffer = gl.createBuffer();
const texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
const texCoordBuffer = gl.createBuffer();

const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
const iTimeLocation = gl.getUniformLocation(program, "iTime");
const mirrorPosLocation = gl.getUniformLocation(program, "mirrorPos");

const init = async () => {
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
        -1.0, 1.0,
        1.0, 1.0,
        -1.0, -1.0,

        -1.0, -1.0,
        1.0, 1.0,
        1.0, -1.0
    ]),
    gl.STATIC_DRAW);
  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,

        0.0, 1.0,
        1.0, 0.0,
        1.0, 1.0,
    ]),
    gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texCoordAttributeLocation);
  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);



  $video.addEventListener('canplay', (event) => {
    console.log('video can start');
    uploadImageToTexture($video, "iChannel0", 0);

    canvas.width = $video.videoWidth;
    canvas.height = $video.videoHeight;

    gl.uniform3f(iResolutionLocation, canvas.width, canvas.height, 0);
    gl.uniform1f(mirrorPosLocation, 0.3);
    drawScene();

  });      
};

const drawScene = (time = 0) => {
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(program);
  uploadImageToTexture($video, "iChannel0", 0);
  gl.uniform1f(iTimeLocation, time / 1000);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  requestAnimationFrame(drawScene);
};

const loadImage = (src) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.addEventListener("load", () => resolve(img));
    img.addEventListener("error", err => reject(err));
    img.src = src;
  });
};

const textures = {};

const map = (value, x1, y1, x2, y2) => (value - x1) * (y2 - x2) / (y1 - x1) + x2;

const uploadImageToTexture = (img, uniformName, textureUnitIndex) => {
  const u_imageLoc = gl.getUniformLocation(program, uniformName);
  gl.uniform1i(u_imageLoc, textureUnitIndex);

  if (!textures[uniformName]) {
    textures[uniformName] = gl.createTexture();
  }

  const texture = textures[uniformName];
  gl.activeTexture(gl.TEXTURE0 + textureUnitIndex);
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Set the parameters so we can render any size image.
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

  // Upload the image into the texture.
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
};

init();
}
  </script>
</body>
</html>